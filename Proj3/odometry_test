from robomaster import robot
from matplotlib import pyplot
import time
import threading
import numpy as np
from scipy import interpolate
import csv
import pandas as pd
import math
import cv2
import zmq
# communication initialization
context = zmq.Context()
socket = context.socket(zmq.PAIR)
socket.connect("tcp://192.168.1.171:5555")
print("Connecting to ROBOT2â€¦")


<<<<<<< HEAD
ep_robot = robot.Robot()
# ep_robot.initialize(conn_type="sta", sn="3JKCH8800100TY")

ep_sensor = ep_robot.sensor
ep_chassis = ep_robot.chassis
=======
>>>>>>> ad173a36c2a434700cd04f269e1d6e5f8232ba1e

def sub_position_handler(p, x_new):
    x_new[0] = p[0]
    x_new[1] = p[1]
    x_new[2] = p[2]
    # print("chassis position: x: {}".format(x_new))

wait_to_start_moving = True
def move_square(ep_chassis, x_len=.5, y_len=.5, speed=1.0):
    while True:
        ep_chassis.move(x=x_len,  y=0,      z=0, xy_speed=speed).wait_for_completed()
        ep_chassis.move(x=0,      y=y_len,  z=0, xy_speed=speed).wait_for_completed()
        ep_chassis.move(x=-x_len, y=0,      z=0, xy_speed=speed).wait_for_completed()
        ep_chassis.move(x=0,      y=-y_len, z=0, xy_speed=speed).wait_for_completed()

if __name__ == '__main__':
    ep_robot = robot.Robot()
    ep_robot.initialize(conn_type="sta", sn="3JKCH8800100WV")
    ep_sensor = ep_robot.sensor
    ep_chassis = ep_robot.chassis
    # Wheel odometry position estimates for rescaling visual odometry t vector
    x_old = np.zeros((3,))
    x_new = np.zeros((3,))
    frame_undistorted_gray_old = None
<<<<<<< HEAD
    ep_robot = robot.Robot()
    ep_robot.initialize(conn_type="sta", sn="3JKCH8800100TY")

    
    # ep_robot.initialize(conn_type="ap")
=======

>>>>>>> ad173a36c2a434700cd04f269e1d6e5f8232ba1e
    ep_robot.chassis.sub_position(cs = 0,freq=50, callback=lambda p: sub_position_handler(p, x_new))
    ep_camera = ep_robot.camera
    ep_camera.start_video_stream(display=False)

    x = threading.Thread(target=move_square, daemon=True, args=(ep_robot.chassis,))
    x.start()

    start = (2,2)

    while True:
        x_curr = x_new[0]
        y_curr = x_new[1]
        print(x_curr,y_curr)
        x_old = np.copy(x_new)